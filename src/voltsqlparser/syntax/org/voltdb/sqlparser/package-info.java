/* This file is part of VoltDB.
 * Copyright (C) 2008-2017 VoltDB Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with VoltDB.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * <h2>Rationale</h2>
 * This is a project to create a complete SQL parser from first
 * principles.  The overall goal is to create a parser which will
 * parse the dialect of SQL which VoltDB uses, and produce VoltXMLElement
 * objects describing it. These VoltXMLElement objects are very
 * stylized XML objects which VoltDB uses to represent SQL ASTs.
 *
 * Our principle is to separate syntax, static semantics, and
 * dynamic semantics one from the other.  It's terribly confusing
 * to mix up all three parts, when they can be clearly separated with
 * a little care from the beginning.  So, the code is separated
 * into four parts.
 * <ol>
 *   <li>The source folder <code>target/generated-sources/antlr4</code>
 *       contains packages to manage the parser.  All code in this
 *       source folder is generated by the Antlr4 tool.  None of
 *       this should be committed to git.  It's not really very instructive
 *       to read this code, but it's possible.</li>
 *   <li>The source folder <code>src/voltsqlparser/syntax<code> contains
 *       the grammar, in the file <code>SQLParser.g4</code>, the
 *       lexer, in the file <code>SQLLexer.g4</code>. and definitions
 *       of interfaces which the static semantics and dynamic semantics
 *       layers provide for building data structures to hold the representations
 *       of SQL. The syntax layer really knows nothing about the data structures
 *       except for what the interfaces can do.</li>
 *   <li>The source folder <code>src/voltsqlparser/semantics</code> contains
 *       the implementations of some of the interfaces used by the syntax
 *       layer.  The only interfaces not implemented here are the abstractions
 *       of the actual semantic objects and their creations.  In particular,
 *       the semantics layer knows about the types it creates, but it knows
 *       nothing about Abstract Syntax Trees or VoltXMLElement.  To the
 *       semantics layer, the ASTs are simply objects which implement the
 *       IAST interface, and this is very narrow indeed.</li>
 *   <li>The package <code>org.voltdb.hsqldb_voltpatches</code> contains the
 *       definitions of implementations of <code>VoltParserFactory</code> and
 *       <code>VoltDDLListener.</code>  The former implements the rest of the
 *       factory methods, while the former implements methods called by
 *       methods called by the parser, such as to create ASTs.
 *       <p>
 *       Note that these are probably completely misplaced.
 *       However, they are easily moved.  Since VoltXMLElement is in this HSQLDB
 *       specific package, and these classes are mostly concerned with
 *       VoltXMLElement generation, it's convenient to place them here.
 * </ol>
 *
 * <h2>Data Structures</h1>
 *
 *   select t.otherint + ( select someint*2 from t where id=100 ) from s;
 *
 * When we see the subquery, we to suspend the state of the outer select
 * parsing, which saves the state of the outer expression parsing, and
 * start a new select parser, which can parse the expression "somint*2".
 * Eventually we will end up with a scalar subquery expression which we
 * can use to complete the outer select list element.
 *
 * There are expressions several kinds of DQL and DML statements.
 * <ul>
 *   <li>In select queries there are expressions in
 *       select list elements, join conditions, group by keys,
 *       where filters, having filters and order by keys.</li>
 *   <li>In delete statements there are expressions in where filters and
 *       sort keys.</li>
 *   <li>In insert into select there are all the kinds of expressions found
 *       in select statements.</li>
 *   <li>Update statements have where filters and the right hands of
 *       assignments.</li>
 * </ul>
 *
 * Each kind of statement has an expression parser, though an insert
 * statement has an embedded select statement processor.  So, the insert
 * only contains expressions indirectly.  The statement is
 * responsible for initializing this parser, and delivering up its
 * answer when asked.
 *
 * There are several kinds of statement processors.  Each processor
 * is an object which implements a particular interface, as shown in
 * this table.
 *
 * <table border="1">
 *   <tr><th colspan="2">DDL STATEMENTS     </th>                         </tr>
 *   <tr><th>Statement Kind     </th><th>Processor Interface</th></tr>
 *   <tr> <td> ALTER TABLE      </td> <td> IAlterTableStatement     </td> </tr>
 *   <tr> <td> CREATE TABLE     </td> <td> ICreateTableStatement    </td> </tr>
 *   <tr> <td> CREATE INDEX     </td> <td> ICreateIndexStatement    </td> </tr>
 *   <tr> <td> CREATE VIEW      </td> <td> ICreateViewStatement     </td> </tr>
 *   <tr> <td> CREATE PROCEDURE </td> <td> ICreateProcedureStatement</td> </tr>
 *   <tr> <td> CREATE ROLE      </td> <td> ICreateRoleStatement     </td> </tr>
 *   <tr> <td> DR ...           </td> <td> IDRStatement             </td> </tr>
 *   <tr> <td> DROP ...         </td> <td> IDropStatement           </td> </tr>
 *   <tr> <td> EXPORT ...       </td> <td> IExportStatement         </td> </tr>
 *   <tr> <td> IMPORT ...       </td> <td> IImportStatement         </td> </tr>
 *   <tr> <td> PARTITION ...    </td> <td> IPartitionStatement      </td> </tr>
 *   <tr> <td> TRUNCATE TABLE   </td> <td> ITruncateStatement       </td> </tr>
 *   <tr> <td> SET ...          </td> <td> ISetStatement            </td> </tr>
 *   <tr> <th colspan="2">DML STATEMENTS    </th>                         </tr>
 *   <tr><th>Statement Kind     </th><th>Processor Interface</th></tr>
 *   <tr> <td> INSERT INTO ...  </td> <td> IInsertStatement         </td> </tr>
 *   <tr> <td> UPDATE ...       </td> <td> IUpdateStatement         </td> </tr>
 *   <tr> <td> DELETE ...       </td> <td> IDeleteStatement         </td> </tr>
 *   <tr> <th colspan="2">DQL STATEMENTS    </th>                         </tr>
 *   <tr><th>Statement Kind     </th><th>Processor Interface</th></tr>
 *   <tr> <td> SELECT ...       </td> <td> ISelectQuery             </td> </tr>
 * </table>
 *
 * The interface hierarchy is:
 *    <ul>
 *      <li>IDDLStatement
 *        <ul>
 *          <li>IAlterTableStatement</li>
 *          <li>ICreateTableStatement
 *            <ul>
 *              <li>ICreateViewStatement</li>
 *            </ul>
 *          </li>
 *          <li>ICreateIndexStatement</li>
 *          <li>ICreateProcedureStatement
 *            <ul>
 *              <li>ICreateProcedureFromJavaStatement</li>
 *              <li>ICreateProcedureFromSQLStatement</li>
 *            </ul>
 *          </li>
 *          <li>ICreateRoleStatement</li>
 *          <li>IDRStatement</li>
 *          <li>IDropStatement
 *            <ul>
 *              <li>IDropTableStatement</li>
 *              <li>IDropViewStatement</li>
 *              <li>DropRoleStatement</li>
 *              <li>IDropStreamStatement</li>
 *              <li>IDropProcedureStatement</li>
 *              <li>IDropIndexStatement</li>
 *            </ul>
 *          </li>
 *        </ul>
 *      </li>
 *      <li>IDMLStatement
 *         <ul>
 *           <li>IInsertStatement</li>
 *           <li>IUpdateStatement</li>
 *           <li>IDeleteStatement</li>
 *         </ul>
 *      </li>
 *      <li>IDQLStatement
 *         <ul>
 *           <li>ISelectStatement</li>
 *         </ul>
 *      </li>
 *    </ul>
 *
 *
 *
 * <h2>Expressions and {@link org.voltdb.sqlparser.syntax.grammar.ISemantino}s.</h2>
 *
 * The representation of an expression is an ISemantino.  This is an
 * indivisble unit of semantics, something like a Neutrino is an indivisble
 * unit of matter.  However, like neutrinos, ISemantinos have attributes.
 * <ol>
 *   <li>One of the attributes is the ISemantino's type.</li>
 *   <li>We can extract an abstract syntax tree from the ISemantio.  The
 *       type of this AST is IAST.  This is the abstraction of VoltXMLElement.
 *       An IAST just a marker interface, with no methods.</li>
 *   <li>We can tell if an ISemantino is the error semantino.</li>
 * </ol>
 *
 * <h2>Types</h2>
 * A type is represented by objects which implement the IType interface. The set
 * of types is pretty much fixed by the SQL standard, and by VoltDB.  There are
 * no user defined types, and no types created with DDL.  This simplifies the
 * type system a great deal.
 *
 * All the types are created in the <em>StandardPrelude</em>, which is an {@link org.voltdb.sqlparser.syntax.symtab.ISymbolTable}.
 * There are the usual integer and float types, VARCHAR and VARBINARY types and geospatial types.
 * There are also some internally useful types.  These are the Types
 * {@link org.voltdb.sqlparser.semantics.symtab.VoidType}
 * and {@link org.voltdb.sqlparser.semantics.symtab.ErrorType}.
 * The former is used for operations which do not return values.  The latter are used when
 * errors occur for which the type is not obvious.
 *
 * There are some common operations that help to classify types.
 * <ol>
 *   <li>{@link org.voltdb.sqlparser.syntax.symtab.IType#isBooleanType}, {@link org.voltdb.sqlparser.syntax.symtab.IType#isVoidType}, {@link IType.isErrorType}
 *       and {@link IType.isFixedSizeType} classify types as boolean, void and error types.
 *       Others are logically necessary.</li>
 *   <li>
 * </ol>
 *
 * The only non-trivial operation on an IType is {@link evalConstant}.  This operation takes a
 * string and returns a semantino for the value of the type represented by the string.
 * For example, if <code>b</code> is an object of type {@link IBoolean}, then
 * <code>b.evalConstant("false")</code> would return the false ISemantino.
 *
 * <h2>Symbol Tables</h2>
 * An {@link ISymbolTable} performs name lookups.  Names are introduced by <code>FROM</code>
 * clauses in SELECT statements.
 */
 package org.voltdb.sqlparser;

