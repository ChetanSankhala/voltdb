CREATE TABLE P1 (
  ID INTEGER DEFAULT '0' NOT NULL,
  DESC VARCHAR(300),
  NUM INTEGER NOT NULL,
  NUM2 INTEGER NOT NULL,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);

PARTITION TABLE P1 ON COLUMN ID;

CREATE TABLE R1IX ( 
  ID INTEGER DEFAULT '0' NOT NULL, 
  DESC VARCHAR(300), 
  NUM INTEGER NOT NULL, 
  RATIO FLOAT NOT NULL, 
  CONSTRAINT R1IX_PK_TREE PRIMARY KEY (ID) 
); 
CREATE INDEX R1IX_IDX_NUM_TREE ON R1IX (NUM); 
CREATE INDEX R1IX_IDX_RATIO_TREE ON R1IX (RATIO); 
CREATE INDEX R1IX_IDX_DESC_TREE ON R1IX (DESC);

CREATE TABLE R1 (
  ID INTEGER DEFAULT '0' NOT NULL,
  DESC VARCHAR(300),
  NUM INTEGER NOT NULL,
  NUM2 INTEGER NOT NULL,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);

CREATE TABLE P2 (
  ID INTEGER DEFAULT '0' NOT NULL,
  DESC VARCHAR(300),
  NUM INTEGER NOT NULL,
  NUM2 INTEGER NOT NULL,
  RATIO FLOAT NOT NULL,
  CONSTRAINT P2_PK_TREE PRIMARY KEY (ID)
);
CREATE INDEX P2_IDX_NUM_TREE ON P2 (NUM);

PARTITION TABLE P2 ON COLUMN ID;

CREATE TABLE R2 (
  ID INTEGER DEFAULT '0' NOT NULL,
  DESC VARCHAR(300),
  NUM INTEGER NOT NULL,
  NUM2 INTEGER NOT NULL,
  RATIO FLOAT NOT NULL,
  CONSTRAINT R2_PK_TREE PRIMARY KEY (ID)
);
CREATE INDEX R2_IDX_NUM_TREE ON R2 (NUM);

CREATE TABLE P3 (
  ID INTEGER DEFAULT '0' NOT NULL,
  DESC VARCHAR(300),
  NUM INTEGER NOT NULL,
  NUM2 INTEGER NOT NULL,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);
CREATE INDEX P3_IDX_COMBO ON P3 (NUM, NUM2);

PARTITION TABLE P3 ON COLUMN ID;

CREATE TABLE R3 (
  ID INTEGER DEFAULT '0' NOT NULL,
  DESC VARCHAR(300),
  NUM INTEGER NOT NULL,
  NUM2 INTEGER NOT NULL,
  RATIO FLOAT NOT NULL,
  PRIMARY KEY (ID)
);
CREATE INDEX R3_IDX_COMBO ON R3 (NUM, NUM2);

CREATE TABLE BINGO_BOARD (
 T_ID INTEGER NOT NULL,
 B_ID INTEGER NOT NULL,
 LAST_VALUE VARCHAR(128),
 CONSTRAINT B_PK_TREE PRIMARY KEY (T_ID, B_ID)
);

CREATE TABLE MANY_INTS (
  ID1 BIGINT NOT NULL,
  ID2 BIGINT NOT NULL,
  ID3 BIGINT NOT NULL,
  ID4 BIGINT NOT NULL,
  ID5 BIGINT NOT NULL,
  PRIMARY KEY (ID1, ID2, ID3, ID4)
);
CREATE INDEX IDX ON MANY_INTS (ID1, ID2, ID3, ID4, ID5);

-- special compound index schema for ENG-5537
CREATE TABLE tableX
(
    keyA INT NOT NULL,
    keyB INT NOT NULL,
    keyC SMALLINT DEFAULT '0',
    keyD VARCHAR(20),
    sort1 SMALLINT DEFAULT '3',
    keyE INT NOT NULL,
    PRIMARY KEY (keyA,keyB,keyD)
);

PARTITION TABLE tableX ON COLUMN keyA;

CREATE INDEX idx_x ON tableX(keyA,keyC,keyD,keyE);

CREATE TABLE tableY (
    keyA INT NOT NULL,
    keyB INT NOT NULL,
    keyH INT NOT NULL,
    keyI INT NOT NULL,
    PRIMARY KEY (keyA,keyB,keyH,keyI)
);

PARTITION TABLE tableY ON COLUMN keyA;

CREATE INDEX idx_y_keyI ON tableY(keyH,keyI);

-- tree index on varbinary type
CREATE TABLE varbinaryTableTree (
    id INTEGER NOT NULL,
    varb2 VARBINARY(2),
    varb512 VARBINARY(512)
);
CREATE INDEX varbinaryTableTree_INDEX_varb2 ON varbinaryTableTree(varb2);
CREATE INDEX varbinaryTableTree_INDEX_varb512 ON varbinaryTableTree(varb512);

-- ENG-10478
-- Sometimes we mangle boolean expressions of the form "col < 42 and col < 26661"
-- when "col" is the same table in both conjuncts.  See TestIndexesSuite.testBooleanExpressions.
DROP VIEW V_BTEST_R2_ABS IF EXISTS;
DROP TABLE BTEST_R2 IF EXISTS;
CREATE TABLE BTEST_R2 (
    ID          INTEGER NOT NULL, 
    WAGE        SMALLINT, 
    DEPT        SMALLINT, 
    AGE         SMALLINT, 
    RENT        SMALLINT, 
    PRIMARY KEY (ID)
);
CREATE VIEW V_BTEST_R2_ABS 
    (V_G1, V_G2, V_CNT, V_sum_age, V_sum_rent) 
AS  SELECT ABS(wage), dept, count(*), sum(age), sum(rent)  
        FROM BTEST_R2 
        GROUP BY ABS(wage), dept;

CREATE TABLE ENG13725_R4 (
  ID      INTEGER  DEFAULT 0,
  TINY    TINYINT  DEFAULT 0,
  SMALL   SMALLINT DEFAULT 0,
  INT     INTEGER  DEFAULT 0,
  BIG     BIGINT   DEFAULT 0,
  NUM     FLOAT    DEFAULT 0,
  DEC     DECIMAL  DEFAULT 0,
  VCHAR_INLINE      VARCHAR(14)       DEFAULT '0',
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES) DEFAULT '0',
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES) DEFAULT '0' NOT NULL,
  VCHAR             VARCHAR           DEFAULT '0',
  VCHAR_JSON        VARCHAR(1000)     DEFAULT '0',
  TIME    TIMESTAMP       DEFAULT '2013-10-30 23:22:29',
  VARBIN  VARBINARY(100)  DEFAULT x'00',
  -- Default values of GEOGRAPHY_POINT and GEOGRAPHY not supported (ENG-12028)
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID, VCHAR_OUTLINE_MIN)
);
-- Will not work with SqlCoverage/PostgreSQL (2 lines):
CREATE UNIQUE INDEX ENG13725_IDX_R4_TV  ON ENG13725_R4 (TINY, VCHAR);
CREATE UNIQUE INDEX ENG13725_IDX_R4_VSI ON ENG13725_R4 (VCHAR, SMALL, INT);

CREATE VIEW ENG13725_VR4 (VCHAR, BIG,
ID, TINY, SMALL, INT, NUM, DEC,
VCHAR_INLINE, VCHAR_INLINE_MAX, VCHAR_OUTLINE_MIN, VCHAR_JSON, TIME
-- Will not work with SqlCoverage/PostgreSQL:
, VARBIN, POINT, POLYGON
, IPV4, IPV6, VBIPV4, VBIPV6
) AS
SELECT VCHAR, BIG,
COUNT(*), SUM(TINY), MAX(SMALL), COUNT(VCHAR_INLINE_MAX), MAX(NUM), MIN(DEC),
MAX(VCHAR_INLINE), MIN(VCHAR_INLINE_MAX), MAX(VCHAR_OUTLINE_MIN), MIN(VCHAR_JSON), MAX(TIME)
-- Will not work with SqlCoverage/PostgreSQL:
, MIN(VARBIN), MAX(POINT), MIN(POLYGON)
, MAX(IPV4), MIN(IPV6), MAX(VBIPV4), MIN(VBIPV6)
FROM ENG13725_R4 WHERE VCHAR_INLINE < 'N'
GROUP BY VCHAR, BIG;
CREATE INDEX ENG13725_IDX_VR4_VB  ON ENG13725_VR4 (VCHAR, BIG)             WHERE BIG >= 0;
CREATE INDEX ENG13725_IDX_VR4_IDV ON ENG13725_VR4 (INT, DEC, VCHAR_INLINE) WHERE VCHAR_INLINE < 'a';
CREATE INDEX ENG13725_IDX_VR4_VMB ON ENG13725_VR4 (VCHAR_INLINE_MAX, BIG)  WHERE BIG >= 0 AND VCHAR_INLINE_MAX IS NOT NULL;

CREATE TABLE ENG13725_R21 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(14),
  VCHAR_INLINE_MAX  VARCHAR(63 BYTES),
  VCHAR_OUTLINE_MIN VARCHAR(64 BYTES),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(1000),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (ID)
);

CREATE INDEX ENG13725_IDX_R21_TINY ON ENG13725_R21 (TINY);
CREATE INDEX ENG13725_IDX_R21_BIG  ON ENG13725_R21 (BIG);
CREATE INDEX ENG13725_IDX_R21_DEC  ON ENG13725_R21 (DEC);
CREATE INDEX ENG13725_IDX_R21_VIM  ON ENG13725_R21 (VCHAR_INLINE_MAX);
CREATE INDEX ENG13725_IDX_R21_TIME ON ENG13725_R21 (TIME);
CREATE INDEX ENG13725_IDX_R21_VBIN ON ENG13725_R21 (VARBIN);
CREATE INDEX ENG13725_IDX_R21_POLY ON ENG13725_R21 (POLYGON);
-- Define "standard" DDL (tables, indexes, views), for use with the SQL grammar generator

CREATE TABLE ENG13725_R3 (
  ID      INTEGER NOT NULL,
  TINY    TINYINT,
  SMALL   SMALLINT,
  INT     INTEGER,
  BIG     BIGINT,
  NUM     FLOAT,
  DEC     DECIMAL,
  VCHAR_INLINE      VARCHAR(42 BYTES),
  VCHAR_INLINE_MAX  VARCHAR(15),
  VCHAR_OUTLINE_MIN VARCHAR(16),
  VCHAR             VARCHAR,
  VCHAR_JSON        VARCHAR(4000 BYTES),
  TIME    TIMESTAMP,
  VARBIN  VARBINARY(100),
  POINT   GEOGRAPHY_POINT,
  POLYGON GEOGRAPHY,
  -- Used to test internet address functions:
  -- INET6_ATON, INET6_NTOA, INET_ATON, INET_NTOA
  IPV4    VARCHAR(15),
  IPV6    VARCHAR(60),
  VBIPV4  VARBINARY(4),
  VBIPV6  VARBINARY(16),
  PRIMARY KEY (VCHAR)
  -- Will not work with SqlCoverage/PostgreSQL (2 lines):
  , CONSTRAINT ENG13725_IDX_R3_TV  UNIQUE (TINY, VCHAR)
  , CONSTRAINT ENG13725_IDX_R3_VSI UNIQUE (VCHAR_INLINE, INT, NUM)
);
